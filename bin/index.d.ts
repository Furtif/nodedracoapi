/// <reference types="node" />
import * as long from 'long';
import * as objects from './draco/objects';
import * as enums from './draco/enums';
import { Fight } from './fight';
import { Inventory } from './inventory';
import { Eggs } from './eggs';
import { Creatures } from './creatures';
export declare class User {
    id: string;
    deviceId: string;
    nickname: string;
    avatar: number;
    login: string;
    username: string;
    password: string;
}
export { enums };
export { objects };
export declare class Client {
    clientInfo: objects.FClientInfo;
    user: User;
    fight: Fight;
    inventory: Inventory;
    eggs: Eggs;
    creatures: Creatures;
    protocolVersion: string;
    clientVersion: string;
    private request;
    private proxy;
    private dcportal;
    private checkProtocol;
    private auth;
    private configHash;
    eventsCounter: any;
    utcOffset: number;
    constructor(options?: any);
    private getAccuracy;
    ping(throwIfError?: boolean): Promise<boolean>;
    call(service: string, method: string, body: any): Promise<any>;
    post(url: string, data: any): Promise<void>;
    event(name: any, one?: any, two?: any, three?: any): Promise<void>;
    boot(clientinfo: any): Promise<objects.FConfig>;
    getConfig(): Promise<objects.FConfig>;
    buildConfigHash(config: objects.FConfig): Buffer;
    login(): Promise<any>;
    googleLogin(): Promise<void>;
    load(): Promise<void>;
    validateNickname(nickname: any): Promise<any>;
    acceptTos(): Promise<void>;
    acceptLicence(licence: any): Promise<any>;
    register(nickname: any): Promise<any>;
    getNews(lastSeen: string): Promise<any>;
    generateAvatar(options?: any): number;
    setAvatar(avatar: any): Promise<any>;
    selectAlliance(alliance: enums.AllianceType, bonus: number): Promise<any>;
    acknowledgeNotification(type: string): Promise<any>;
    getMapUpdate(latitude: number, longitude: number, horizontalAccuracy?: number, tilesCache?: Map<objects.FTile, long>): Promise<objects.FUpdate>;
    useBuilding(clientLat: number, clientLng: number, buildingId: string, buildingLat: number, buildingLng: number): Promise<any>;
    openChest(chest: objects.FChest): Promise<any>;
    leaveDungeon(latitude: number, longitude: number, horizontalAccuracy?: number): Promise<any>;
    delay<T>(ms: number, value?: T): Promise<T>;
}
